<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Stellar Guitar Tuner</title>

<style>
  :root{
    --bg:#0a0d14; --bg2:#070a12; --glow:#99e1ff; --glow2:#7ef0c9;
    --text:#e8ecf1; --ok:#72e6a6; --warn:#f1c40f; --bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{
    display:grid;place-items:center;color:var(--text);
    font:800 16px/1.45 ui-sans-serif,system-ui,-apple-system,"Segoe UI",Inter,Roboto,Arial;
    background:
      radial-gradient(1200px 800px at 20% 10%, #12203a 0%, transparent 65%),
      radial-gradient(1100px 700px at 80% -10%, #0e1a31 0%, transparent 60%),
      linear-gradient(180deg,var(--bg),var(--bg2));
    overflow:hidden;
  }
  /* Nebula parallax + twinkling stars */
  .space{
    position:fixed; inset:0; pointer-events:none; z-index:-1;
    background:
      radial-gradient(1200px 900px at 30% 20%, rgba(0,180,255,.18) 0%, transparent 55%),
      radial-gradient(900px 700px at 70% 15%, rgba(0,255,170,.15) 0%, transparent 60%),
      repeating-radial-gradient(circle at 50% 50%, rgba(255,255,255,.06) 0 0.3px, transparent 0.3px 3px);
    animation: drift 36s linear infinite;
    filter:saturate(110%) blur(.2px);
  }
  .streaks::before,
  .streaks::after{
    content:""; position:absolute; inset:-10%; pointer-events:none;
    background:
      radial-gradient(ellipse at 10% 20%, rgba(255,255,255,.25) 0 12%, transparent 35%),
      radial-gradient(ellipse at 80% 30%, rgba(255,255,255,.12) 0 10%, transparent 35%),
      radial-gradient(ellipse at 40% 5%, rgba(255,255,255,.20) 0 8%, transparent 30%);
    mix-blend-mode:screen; filter:blur(2px);
    animation: pan 18s linear infinite reverse;
  }
  @keyframes drift{
    0%{transform:translate3d(0,0,0)}
    50%{transform:translate3d(2%, -2%, 0)}
    100%{transform:translate3d(0,0,0)}
  }
  @keyframes pan{
    0%{transform:translateX(-4%) translateY(-2%) rotate(0.2deg)}
    50%{transform:translateX(4%) translateY(2%) rotate(-0.2deg)}
    100%{transform:translateX(-4%) translateY(-2%) rotate(0.2deg)}
  }

  svg{width:min(92vw,980px);height:auto;display:block;filter:drop-shadow(0 20px 40px rgba(0,0,0,.35))}
  /* Arc & ticks */
  path.arc{stroke-linecap:round; filter: drop-shadow(0 6px 18px rgba(0,0,0,.35))}
  #ticks line{vector-effect:non-scaling-stroke; stroke-linecap:round; opacity:.95; filter:drop-shadow(0 1px 1px rgba(0,0,0,.35))}
  /* Needle & comet */
  #needle{filter:drop-shadow(0 10px 26px rgba(0,0,0,.55)) drop-shadow(0 0 8px rgba(255,255,255,.08))}
  #cometTrail{mix-blend-mode:screen; filter:url(#trailBlur)}
  #sparkle{filter:url(#sparkleBlur)}

  .note{
    margin-top: clamp(12px, 3.5vh, 24px);
    font-size:clamp(48px,11vw,96px); font-weight:900; letter-spacing:.02em; text-align:center;
    text-shadow: 0 1px 0 rgba(0,0,0,.35), 0 12px 28px rgba(0,0,0,.25);
    transition:color .25s ease, text-shadow .25s ease;
  }
  .note.ok{ color:var(--ok); text-shadow:0 0 22px rgba(114,230,166,.35), 0 12px 28px rgba(0,0,0,.25)}
  .note.warn{color:var(--warn);text-shadow:0 0 22px rgba(241,196,15,.35), 0 12px 28px rgba(0,0,0,.25)}
  .note.bad{ color:var(--bad); text-shadow:0 0 22px rgba(255,107,107,.35), 0 12px 28px rgba(0,0,0,.25)}

  @media (prefers-reduced-motion: reduce){
    .space,.streaks::before,.streaks::after{animation:none}
    *{transition:none !important}
  }
  /* Stick-figure overlay */
#stickWrap{
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  pointer-events: none;
  z-index: 10;
}

#stick{
  opacity: 0;           /* we toggle this in JS */
  transform: translateZ(0);
  transition: opacity .25s ease;
  filter: drop-shadow(0 8px 20px rgba(0,0,0,.5));
}

/* Simple dancing animation */
@keyframes dance {
  0%   { transform: translateY(0) rotate(0deg); }
  20%  { transform: translateY(-6px) rotate(-3deg); }
  40%  { transform: translateY(0) rotate(0deg); }
  60%  { transform: translateY(-6px) rotate(3deg); }
  80%  { transform: translateY(0) rotate(0deg); }
  100% { transform: translateY(-2px) rotate(-2deg); }
}

#stick svg{
  width: min(28vw, 220px);
  height: auto;
  animation: dance 1.1s ease-in-out infinite;
  /* subtle glow */
  filter: drop-shadow(0 0 12px rgba(255,255,255,.12));
}<svg>…</svg>
</style>
</head>
<body>
<div class="space streaks"></div>

<div>
  <svg viewBox="0 0 1000 700" aria-hidden="true">
    <defs>
      <!-- Arc gradient -->
      <linearGradient id="arcgrad" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%"   stop-color="#ff6b6b"/>
        <stop offset="35%"  stop-color="#f1c40f"/>
        <stop offset="50%"  stop-color="#72e6a6"/>
        <stop offset="65%"  stop-color="#f1c40f"/>
        <stop offset="100%" stop-color="#ff6b6b"/>
      </linearGradient>

      <!-- Trail gradient (bright head -> transparent tail) -->
      <linearGradient id="trailgrad" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="#c8f8ff"/>
        <stop offset="35%" stop-color="#8ae6ff" stop-opacity=".9"/>
        <stop offset="65%" stop-color="#6af0c8" stop-opacity=".55"/>
        <stop offset="100%" stop-color="#6af0c8" stop-opacity="0"/>
      </linearGradient>

      <!-- Blur for trail & sparkle -->
      <filter id="trailBlur" x="-10%" y="-10%" width="120%" height="120%">
        <feGaussianBlur stdDeviation="2.2" result="b"/>
      </filter>
      <filter id="sparkleBlur" x="-20%" y="-20%" width="140%" height="140%">
        <feGaussianBlur stdDeviation="1.6"/>
      </filter>
    </defs>

    <!-- semicircle arc -->
    <path class="arc" d="M200 540 A300 300 0 0 1 800 540" fill="none" stroke="url(#arcgrad)" stroke-width="22"/>

    <!-- ticks -->
    <g id="ticks" transform="translate(500,540)"></g>

    <!-- comet trail (polyline of previous tip positions) -->
    <polyline id="cometTrail" fill="none" stroke="url(#trailgrad)" stroke-linecap="round" stroke-linejoin="round" stroke-width="8" points=""/>

    <!-- pivot & needle -->
    <circle cx="500" cy="540" r="10" fill="#0b0c11" stroke="#3a4052" stroke-width="3"/>
    <g id="needle">
      <polygon points="495,540 505,540 500,240" fill="#e8ecf1"/>
      <circle cx="500" cy="540" r="8" fill="#0b0c11" stroke="#e8ecf1" stroke-width="2"/>
    </g>

    <!-- sparkle dot at tip -->
    <circle id="sparkle" cx="500" cy="240" r="6" fill="#d6fbff"/>
  </svg>

  <div id="noteLabel" class="note">—</div>
</div>
<!-- Stick figure overlay (hidden until audio is too quiet) -->
<div id="stickWrap" aria-hidden="true">
  <div id="stick">
    <!-- Minimal SVG stick figure -->
    <svg viewBox="0 0 120 160" aria-hidden="true">
      <!-- head -->
      <circle cx="60" cy="28" r="14" fill="none" stroke="#e8ecf1" stroke-width="4" />
      <!-- body -->
      <line x1="60" y1="42" x2="60" y2="92" stroke="#e8ecf1" stroke-width="4" stroke-linecap="round"/>
      <!-- arms -->
      <line x1="60" y1="56" x2="30" y2="76" stroke="#e8ecf1" stroke-width="4" stroke-linecap="round"/>
      <line x1="60" y1="56" x2="90" y2="76" stroke="#e8ecf1" stroke-width="4" stroke-linecap="round"/>
      <!-- legs -->
      <line x1="60" y1="92" x2="38" y2="128" stroke="#e8ecf1" stroke-width="4" stroke-linecap="round"/>
      <line x1="60" y1="92" x2="82" y2="128" stroke="#e8ecf1" stroke-width="4" stroke-linecap="round"/>
    </svg>
  </div>
</div>
<script>
(()=>{
// ---------- helpers ----------
const map=(x,a,b,c,d)=> (x-a)*(d-c)/(b-a)+c;
const clamp=(x,a,b)=> Math.max(a,Math.min(b,x));
const stick = document.getElementById("stick");

// ---------- build ticks perfectly on arc ----------
(function(){
  const g=document.getElementById("ticks");
  const R=300, BASE=-90;
  for(let c=-50;c<=50;c+=5){
    const off=map(c,-50,50,-60,60);
    const rad=(BASE+off)*Math.PI/180;
    const len=(c%25===0)?20:(c%10===0?12:6);
    const x1=(R-len)*Math.cos(rad), y1=(R-len)*Math.sin(rad);
    const x2= R     *Math.cos(rad), y2= R     *Math.sin(rad);
    const ln=document.createElementNS("http://www.w3.org/2000/svg","line");
    ln.setAttribute("x1",x1); ln.setAttribute("y1",y1);
    ln.setAttribute("x2",x2); ln.setAttribute("y2",y2);
    ln.setAttribute("stroke", c===0 ? "#72e6a6" : (Math.abs(c)===25 ? "#f1c40f" : "#3a4052"));
    ln.setAttribute("stroke-width", c%25===0?3:2);
    g.appendChild(ln);
  }
})();

// ---------- elements ----------
const needle = document.getElementById("needle");
const noteLabel = document.getElementById("noteLabel");
const trail = document.getElementById("cometTrail");
const sparkle = document.getElementById("sparkle");

// ---------- audio (raw mic) ----------
let AC, analyser, buf, rafId;
const A4=440, NAMES=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
let smoothCents=0, targetAngle=0, currentAngle=0;
let held={name:"—", midi:69, cents:0}, lastMidiRounded=null, stableFrames=0;
const STABLE_FRAMES=6, MAXC=50;

// comet trail state
const TRAIL_LEN=40; // points kept
const cx=500, cy=540, R=300;
const pts = new Array(TRAIL_LEN).fill([cx, cy-R]); // initialize

window.addEventListener("load", start);

async function start(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      audio:{channelCount:1, echoCancellation:false, noiseSuppression:false, autoGainControl:false}
    });
    AC = new (window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive"});
    const mic = AC.createMediaStreamSource(stream);
    analyser = AC.createAnalyser();
    analyser.fftSize = 4096; analyser.smoothingTimeConstant=0.0;
    buf = new Float32Array(analyser.fftSize);
    mic.connect(analyser);
    loop();
  }catch(e){
    noteLabel.textContent="Microphone blocked";
    noteLabel.className="note bad";
  }
}

function loop(){
  rafId = requestAnimationFrame(loop);
  analyser.getFloatTimeDomainData(buf);
  // --- Level detect (no gates; just measure) ---
let sum = 0;
for (let i = 0; i < buf.length; i++) { const v = buf[i]; sum += v*v; }
const rms = Math.sqrt(sum / buf.length);

// Hysteresis so it doesn't flicker
const LOW_RMS = 0.010;    // show dancer below this
const HIGH_RMS = 0.016;   // hide dancer above this (adds hysteresis)
if (loop._quiet === undefined) loop._quiet = true;

if (loop._quiet) {
  if (rms > HIGH_RMS) loop._quiet = false;
} else {
  if (rms < LOW_RMS) loop._quiet = true;
}

// Toggle visibility (opacity only for smoothness)
stick.style.opacity = loop._quiet ? 1 : 0;


  // Try pitch; if we have one, update smoothing inputs & note lock
  const hz = amdfFast(buf, AC.sampleRate);

  if (hz){
    const midi = 69 + 12*Math.log2(hz / A4);
    const midiRounded = Math.round(midi);
    let cents = (midi - midiRounded) * 100;
    cents = clamp(cents, -MAXC, MAXC);

    // Smooth *instant* cents for the needle (EMA)
    const alpha = 0.22;
    smoothCents = isFinite(smoothCents) ? (1 - alpha) * smoothCents + alpha * cents : cents;

    // Lock the displayed note only after short stability
    if (lastMidiRounded === null || midiRounded === lastMidiRounded) {
      stableFrames++;
    } else {
      stableFrames = 0;
    }
    if (stableFrames >= STABLE_FRAMES){
      const name = NAMES[(midiRounded + 1200) % 12] + (Math.floor(midiRounded / 12) - 1);
      held = { name, midi: midiRounded, cents };
    }
    lastMidiRounded = midiRounded;
  }

  // --- Always compute the target from a live source ---
  // If we had a pitch this frame, use smoothCents; otherwise, use held.cents.
  const liveCents = isFinite(smoothCents) ? smoothCents : held.cents;
  const clampedCents = clamp(liveCents, -MAXC, MAXC);
  const desiredAngle = map(clampedCents, -MAXC, MAXC, -60, 60);

  // Time-based easing (critically-damped style) so it feels identical at 60/120Hz
  const now = performance.now();
  if (!loop._t) loop._t = now;
  const dt = Math.min(0.05, (now - loop._t) / 1000); // cap at 50ms to avoid jumps
  loop._t = now;

  const response = 12; // higher = faster tracking (per second)
  const k = 1 - Math.exp(-response * dt);
  currentAngle += (desiredAngle - currentAngle) * k;
  needle.setAttribute("transform", `rotate(${currentAngle} 500 540)`);

  // --- Comet trail & sparkle follow the CURRENT needle angle ---
  const rad = currentAngle * Math.PI / 180;
  const tipX = 500 + 300 * Math.sin(rad);
  const tipY = 540 - 300 * Math.cos(rad);

  pts.unshift([tipX, tipY]);
  if (pts.length > TRAIL_LEN) pts.pop();
  trail.setAttribute("points", pts.map(([x,y])=>`${x.toFixed(1)},${y.toFixed(1)}`).join(" "));

  const t = now / 1000;
  sparkle.setAttribute("cx", tipX);
  sparkle.setAttribute("cy", tipY);
  sparkle.setAttribute("r", 5.5 + 1.5 * Math.abs(Math.sin(t * 2.0)));

  // --- Always show the held note (never blanks) ---
  noteLabel.textContent = held.name;
  const err = Math.abs(held.cents);
  noteLabel.className = "note " + (err<=3 ? "ok" : err<=15 ? "warn" : "bad");
}


/* --------- Fast AMDF with tiny refinement (good for guitar) --------- */
function amdfFast(x, sr){
  const N = x.length;
  const minF=50, maxF=1200;
  const minLag = Math.floor(sr/maxF), maxLag = Math.min(Math.floor(sr/minF), N-1);

  // remove mean + lightweight Hann (in-place scratch to reduce allocs)
  if (!amdfFast._w) amdfFast._w = new Float32Array(N);
  if (!amdfFast._v || amdfFast._v.length < N) amdfFast._v = new Float32Array(N);
  const w = amdfFast._w, v = amdfFast._v;
  let mean=0; for (let i=0;i<N;i++) mean+=x[i]; mean/=N;
  for (let i=0;i<N;i++){
    const win = 0.5*(1-Math.cos(2*Math.PI*i/(N-1)));
    w[i] = (x[i]-mean)*win;
  }

  let bestLag=-1, best=Infinity;
  for (let lag=minLag; lag<=maxLag; lag++){
    let s=0; const L = N-lag;
    for (let i=0;i<L;i++){ const d=w[i]-w[i+lag]; s+= (d<0? -d : d); }
    const val = s / L;
    v[lag] = val;
    if (val<best){ best=val; bestLag=lag; }
  }
  if (bestLag<2) return null;
  if (bestLag===minLag || bestLag===maxLag) return sr / bestLag;

  // refine with simple parabola around bestLag using cached AMDF values
  const y1=v[bestLag-1], y2=v[bestLag], y3=v[bestLag+1];
  const a=(y1+y3-2*y2)/2, b=(y3-y1)/2;
  const refined = a ? bestLag - b/(2*a) : bestLag;
  return sr / refined;
}
})();
</script>
</body>
</html>
